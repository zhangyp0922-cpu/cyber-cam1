<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sodeoka Thermal Cam</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #111;
            overflow: hidden;
            font-family: monospace;
            color: #0f0;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        /* 启动按钮层 */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 99;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        button {
            padding: 15px 30px;
            font-size: 18px;
            background: #0f0;
            color: #000;
            border: none;
            cursor: pointer;
            font-family: monospace;
            margin-bottom: 20px;
        }
        /* 屏幕日志输出，用于排查问题 */
        #logs {
            width: 90%;
            height: 100px;
            overflow-y: auto;
            border: 1px solid #333;
            padding: 10px;
            font-size: 12px;
            color: #aaa;
            background: #000;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <div style="color: #fff; margin-bottom: 20px; font-size: 20px;">Sodeoka 视觉特效</div>
        <button id="btn-start">点击启动摄像头</button>
        <div id="logs">等待用户操作...</div>
    </div>

    <canvas id="glcanvas"></canvas>

<script>
    const logBox = document.getElementById('logs');
    function log(msg) {
        logBox.innerHTML += `> ${msg}<br>`;
        logBox.scrollTop = logBox.scrollHeight;
        console.log(msg);
    }

    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');
    
    if (!gl) {
        log("错误: 您的设备不支持 WebGL。");
    } else {
        log("WebGL 初始化成功。");
    }

    // --- Shader 代码: 热感应/等高线风格 ---
    const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec2 aTextureCoord;
        varying highp vec2 vTextureCoord;
        void main(void) {
            gl_Position = aVertexPosition;
            vTextureCoord = aTextureCoord;
        }
    `;

    const fsSource = `
        precision highp float;
        varying highp vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform float uTime;

        // RGB转亮度
        float getLuma(vec3 color) {
            return dot(color, vec3(0.299, 0.587, 0.114));
        }

        // HSV转RGB (用于生成彩虹色)
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main(void) {
            vec2 uv = vTextureCoord;
            // 镜像翻转
            uv.x = 1.0 - uv.x;
            
            vec4 texColor = texture2D(uSampler, uv);
            float luma = getLuma(texColor.rgb);

            // --- 核心特效: Yoshi Sodeoka 风格 ---
            
            // 1. 制造“液态流动”的等高线
            // 用 sin 函数根据亮度制造波纹，加上 uTime 让它流动
            float wave = sin(luma * 15.0 - uTime * 2.0);
            
            // 2. 边缘锐化 (Posterize)
            // 把连续的波纹变成硬边，像地形图
            float edge = smoothstep(0.0, 0.2, wave) - smoothstep(0.3, 0.5, wave);

            // 3. 迷幻热感配色 (Thermal Mapping)
            // 低亮度=深蓝，高亮度=红/黄/白
            // 这里的 0.7 + luma * 0.8 决定了色相的范围
            vec3 thermalColor = hsv2rgb(vec3(0.6 - luma * 0.6, 1.0, luma * 1.5));

            // 4. 混合线条
            // 如果是波纹边缘，显示为黑色或高亮色
            vec3 finalColor = mix(thermalColor, vec3(1.0, 1.0, 1.0), edge * 0.5);

            gl_FragColor = vec4(finalColor, 1.0);
        }
    `;

    // --- WebGL 样板代码 ---
    function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            log('Shader编译错误: ' + gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }

    const shaderProgram = gl.createProgram();
    const vShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    gl.attachShader(shaderProgram, vShader);
    gl.attachShader(shaderProgram, fShader);
    gl.linkProgram(shaderProgram);

    if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
        log('Program链接错误: ' + gl.getProgramInfoLog(shaderProgram));
    }

    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

    const textureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), gl.STATIC_DRAW);

    const attribs = {
        pos: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
        tex: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
    };
    const uniforms = {
        sampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
        time: gl.getUniformLocation(shaderProgram, 'uTime'),
    };

    // --- 摄像头逻辑 ---
    const video = document.createElement('video');
    video.autoplay = true;
    video.muted = true;
    video.playsInline = true;

    // 创建纹理
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0,0,255,255])); // 默认蓝色

    async function startApp() {
        log("正在请求摄像头权限...");
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            log("摄像头权限已获取。");
            video.srcObject = stream;
            
            // 必须等待视频真正开始播放
            video.onloadeddata = () => {
                log("视频数据流已就绪。开始渲染。");
                video.play();
                document.getElementById('start-screen').style.display = 'none'; // 隐藏启动页
                renderLoop();
            };

        } catch (e) {
            log("摄像头错误: " + e.name + " - " + e.message);
            log("请检查：1. 是否使用HTTPS 2. 是否在Safari设置中拒绝了权限");
        }
    }

    let startTime = 0;
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    function renderLoop(now) {
        if (!startTime) startTime = now;
        const time = (now - startTime) * 0.001;

        if (video.readyState >= video.HAVE_CURRENT_DATA) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
        }

        gl.useProgram(shaderProgram);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(attribs.pos, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attribs.pos);

        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
        gl.vertexAttribPointer(attribs.tex, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(attribs.tex);

        gl.uniform1i(uniforms.sampler, 0);
        gl.uniform1f(uniforms.time, time);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(renderLoop);
    }

    // 绑定按钮点击事件
    document.getElementById('btn-start').addEventListener('click', startApp);

</script>
</body>
</html>
