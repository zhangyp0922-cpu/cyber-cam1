<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Precision Site Survey</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            /* 使用系统等宽字体，更像工程软件 */
            font-family: 'Menlo', 'Consolas', 'Monaco', monospace; 
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            /* 降低对比度，让画面变灰，突出白色的数据线 */
            filter: contrast(0.9) brightness(0.8) grayscale(0.2); 
            z-index: 1;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* 添加一个暗角层，让视觉聚焦中心 */
        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.6) 100%);
            z-index: 3;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="video" autoplay playsinline muted></video>
    <div class="vignette"></div>
    <canvas id="canvas"></canvas>
</div>

<script>
    // --- 配置：精密风格参数 ---
    const config = {
        primaryColor: '#ffffff',      // 主色：纯白
        accentColor: '#FF3B30',       // 强调色：工程红 (像徕卡相机/测绘仪)
        secondaryColor: 'rgba(255, 255, 255, 0.4)', // 辅色：半透明白
        gridColor: 'rgba(255, 255, 255, 0.15)', // 地面网格
        scanSpeed: 2,                 // 扫描线速度
        targetCount: 4                // 目标数量
    };

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let w, h;
    let frame = 0;

    // --- 1. 初始化 ---
    function resize() {
        // 处理高清屏 (Retina)
        const dpr = window.devicePixelRatio || 1;
        w = window.innerWidth;
        h = window.innerHeight;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        ctx.scale(dpr, dpr);
    }
    window.addEventListener('resize', resize);
    resize();

    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            video.srcObject = stream;
        } catch (e) {
            console.warn("Camera fallback");
        }
    }

    // --- 2. 视觉组件类 ---

    // 目标标记 (Target Marker) - 带有旋转光圈和引线
    class Target {
        constructor(id) {
            this.id = id;
            this.reset();
        }

        reset() {
            this.x = Math.random() * (w - 100) + 50;
            this.y = Math.random() * (h * 0.6) + h * 0.2;
            
            // 目标数据
            this.label = `TGT-${(Math.random()*1000).toFixed(0).padStart(4, '0')}`;
            this.dist = (Math.random() * 50 + 10).toFixed(1) + 'm';
            this.type = Math.random() > 0.5 ? 'BIO' : 'STR'; // Biological / Structural
            
            // 动画状态
            this.angle = Math.random() * Math.PI * 2;
            this.spinSpeed = (Math.random() - 0.5) * 0.02;
            this.life = 300 + Math.random() * 300;
            this.opacity = 0;
            
            // 漂浮偏移
            this.floatOffset = Math.random() * Math.PI * 2;
        }

        update() {
            this.life--;
            this.angle += this.spinSpeed;
            
            // 渐入渐出
            if (this.life > 550) this.opacity += 0.02;
            else if (this.life < 50) this.opacity -= 0.02;
            this.opacity = Math.max(0, Math.min(1, this.opacity));

            // 轻微上下浮动
            this.y += Math.sin(frame * 0.02 + this.floatOffset) * 0.3;

            if (this.life <= 0) this.reset();
        }

        draw(ctx) {
            if (this.opacity <= 0.01) return;
            ctx.save();
            ctx.globalAlpha = this.opacity;
            
            const size = 20;

            // 1. 中心十字
            ctx.strokeStyle = config.primaryColor;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(this.x - 5, this.y); ctx.lineTo(this.x + 5, this.y);
            ctx.moveTo(this.x, this.y - 5); ctx.lineTo(this.x, this.y + 5);
            ctx.stroke();

            // 2. 旋转的断开圆环 (Dashed Orbit)
            ctx.strokeStyle = config.secondaryColor;
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 0.5); // 1/4圆
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(0, 0, size, Math.PI, Math.PI * 1.5); // 对角线1/4圆
            ctx.stroke();
            ctx.restore();

            // 3. 引线 (Leader Line) - 类似建筑图纸的标注线
            // 向右上或右下折线
            const labelX = this.x + 40;
            const labelY = this.y - 30;
            
            ctx.strokeStyle = config.primaryColor;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(this.x + size/2, this.y - size/2); // 从圆环边缘开始
            ctx.lineTo(this.x + 25, this.y - 25); // 斜线
            ctx.lineTo(labelX, labelY + 5); // 直线接到文字下
            ctx.stroke();

            // 连接点实心圆
            ctx.fillStyle = config.accentColor; // 红色点
            ctx.beginPath();
            ctx.arc(this.x + 25, this.y - 25, 2, 0, Math.PI*2);
            ctx.fill();

            // 4. 信息卡片 (Info Block)
            ctx.textAlign = 'left';
            
            // 标签背景 (半透明黑)
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(labelX, labelY - 12, 90, 32);
            
            // 顶部高亮条
            ctx.fillStyle = config.primaryColor;
            ctx.fillRect(labelX, labelY - 12, 90, 1);

            // 文字内容
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 10px Menlo';
            ctx.fillText(this.label, labelX + 4, labelY);
            
            ctx.fillStyle = '#ccc';
            ctx.font = '9px Menlo';
            ctx.fillText(`${this.type} / ${this.dist}`, labelX + 4, labelY + 12);

            ctx.restore();
        }
    }

    // 地面扫描网格 (Perspective Grid)
    class ScannerGrid {
        draw(ctx) {
            ctx.save();
            ctx.strokeStyle = config.gridColor;
            ctx.lineWidth = 1;
            
            const horizon = h * 0.55;
            const centerX = w / 2;
            
            // 纵向放射线
            ctx.beginPath();
            for(let i=-5; i<=5; i++) {
                const xOffset = i * (w * 0.3);
                ctx.moveTo(centerX + xOffset * 0.1, horizon);
                ctx.lineTo(centerX + xOffset * 1.5, h);
            }
            ctx.stroke();

            // 横向扫描线 (不断向下移动)
            const scanOffset = (frame * config.scanSpeed) % 200; 
            
            ctx.beginPath();
            // 只画一根亮的扫描线
            let yScan = horizon + Math.pow(scanOffset / 200, 2) * (h - horizon);
            
            ctx.strokeStyle = config.accentColor;
            ctx.globalAlpha = 1 - (scanOffset/200); // 越近越透明
            ctx.lineWidth = 2;
            ctx.moveTo(0, yScan);
            ctx.lineTo(w, yScan);
            ctx.stroke();

            // 画几根固定的淡横线
            ctx.strokeStyle = config.gridColor;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            ctx.beginPath();
            for(let j=0; j<5; j++) {
                let y = horizon + Math.pow(j/5, 2) * (h - horizon);
                ctx.moveTo(0, y);
                ctx.lineTo(w, y);
            }
            ctx.stroke();

            ctx.restore();
        }
    }

    // 屏幕周边的 HUD 装饰 (Frame)
    function drawHUD(ctx) {
        ctx.save();
        ctx.strokeStyle = config.primaryColor;
        ctx.fillStyle = config.primaryColor;
        ctx.lineWidth = 1;

        // 1. 四角括号 (Viewfinder Corners)
        const len = 20;
        const pad = 10;
        
        // 左上
        ctx.beginPath(); ctx.moveTo(pad, pad+len); ctx.lineTo(pad, pad); ctx.lineTo(pad+len, pad); ctx.stroke();
        // 右上
        ctx.beginPath(); ctx.moveTo(w-pad-len, pad); ctx.lineTo(w-pad, pad); ctx.lineTo(w-pad, pad+len); ctx.stroke();
        // 右下
        ctx.beginPath(); ctx.moveTo(w-pad, h-pad-len); ctx.lineTo(w-pad, h-pad); ctx.lineTo(w-pad-len, h-pad); ctx.stroke();
        // 左下
        ctx.beginPath(); ctx.moveTo(pad+len, h-pad); ctx.lineTo(pad, h-pad); ctx.lineTo(pad, h-pad-len); ctx.stroke();

        // 2. 顶部罗盘条 (Compass Strip)
        const compY = 30;
        const center = w/2;
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fillRect(center - 100, 10, 200, 20);
        
        ctx.fillStyle = config.primaryColor;
        ctx.textAlign = 'center';
        ctx.font = '10px Menlo';
        ctx.fillText('N   |   15   |   30   |   NE', center, 24);
        
        // 红色三角指示
        ctx.fillStyle = config.accentColor;
        ctx.beginPath();
        ctx.moveTo(center, 32); ctx.lineTo(center-4, 38); ctx.lineTo(center+4, 38);
        ctx.fill();

        // 3. 底部状态栏
        ctx.textAlign = 'left';
        ctx.font = '10px Menlo';
        ctx.fillText(`REC [${(frame/60).toFixed(2)}]`, 20, h - 20);
        ctx.fillText(`ISO 800  F/2.8`, 120, h - 20);

        ctx.textAlign = 'right';
        ctx.fillText('LIDAR: ON', w - 20, h - 20);

        ctx.restore();
    }

    // --- 3. 运行循环 ---
    const targets = Array.from({length: config.targetCount}, (_, i) => new Target(i));
    const grid = new ScannerGrid();

    function loop() {
        ctx.clearRect(0, 0, w, h);
        frame++;

        // A. 绘制网格
        grid.draw(ctx);

        // B. 绘制目标
        targets.forEach(t => {
            t.update();
            t.draw(ctx);
        });

        // C. 绘制 HUD
        drawHUD(ctx);

        requestAnimationFrame(loop);
    }

    startCamera();
    loop();

</script>
</body>
</html>
