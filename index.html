<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Eco-Analysis Vis</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'Helvetica Neue', Arial, sans-serif; /* 更现代的字体 */
        }
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            opacity: 0.8; /* 稍微压暗一点视频，突出数据 */
            filter: grayscale(40%) contrast(1.1); /* 降低饱和度，接近原图冷淡风 */
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
    </style>
</head>
<body>

<div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
</div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let w, h;
    
    // --- 视觉参数配置 (调整这里可以改变风格) ---
    const config = {
        gridY: 0.6, // 地面网格从屏幕 60% 高度开始
        flowSpeed: 0.5, // 流动速度
        flowColor: 'rgba(255, 255, 255, 0.7)', // 流线点颜色
        lineColor: 'rgba(255, 120, 50, 0.8)', // 橙色连接线 (原图特征)
        boxBorder: 'rgba(255, 255, 255, 0.9)', 
        nodeRed: '#ff3333' // 关键节点的红色
    };

    // 1. 初始化
    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            video.srcObject = stream;
        } catch (e) {
            console.warn("Camera fallback");
        }
    }

    // --- 2. 核心类定义 ---

    // 类：流场波浪 (模拟图中成片的白色虚线流)
    class WaveStream {
        constructor(yBase, amplitude, phase, speed) {
            this.yBase = yBase; // 基础高度
            this.amplitude = amplitude; // 波浪起伏高度
            this.phase = phase; // 初始相位
            this.speed = speed;
            this.points = [];
            // 在水平方向上生成点
            for(let x = 0; x < w; x += 15) { // 每隔15像素一个点
                this.points.push({x: x, offset: Math.random() * 0.5});
            }
        }

        draw(ctx, time) {
            ctx.fillStyle = config.flowColor;
            
            this.points.forEach(p => {
                // 正弦波公式：y = sin(x + time)
                // 加入多重正弦波模拟复杂的“气流”感
                let y = this.yBase 
                      + Math.sin((p.x * 0.01) + time * this.speed + this.phase) * this.amplitude
                      + Math.sin((p.x * 0.02) + time * 0.5) * (this.amplitude * 0.5);

                // 简单的透视模拟：越靠下(近)点越大
                let size = 1.2;
                if (y > h * 0.6) size = 2;

                // 绘制小圆点
                ctx.beginPath();
                ctx.arc(p.x, y, size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
    }

    // 类：数据分析框 (还原原图那种黑白图表风格)
    class DataNode {
        constructor() {
            this.reset();
        }

        reset() {
            this.x = Math.random() * (w - 120);
            this.y = Math.random() * (h * 0.5); // 只在上半部分生成，避免遮挡网格
            
            // 目标连接点（模拟连接到地面的某个位置）
            this.targetX = this.x + (Math.random() - 0.5) * 300;
            this.targetY = h * (0.6 + Math.random() * 0.3); // 连到屏幕下方区域

            this.w = 90; 
            this.h = 110;
            this.label = `[F-Stage${Math.floor(Math.random()*9)}]`;
            
            // 随机生成内部图表的数据高度
            this.bar1 = Math.random();
            this.bar2 = Math.random();
            
            this.life = 400 + Math.random() * 300;
            this.opacity = 0;
            this.state = 0; // 0:in, 1:stay, 2:out
        }

        update() {
            this.life--;
            // 淡入淡出逻辑
            if (this.life > 600) this.opacity += 0.01;
            else if (this.life < 50) this.opacity -= 0.02;
            this.opacity = Math.max(0, Math.min(1, this.opacity));
            
            // 缓慢漂浮
            this.y += Math.sin(Date.now() * 0.001 + this.x) * 0.2;

            if (this.life <= 0) this.reset();
        }

        draw(ctx) {
            if (this.opacity <= 0.01) return;
            
            ctx.save();
            ctx.globalAlpha = this.opacity;

            // 1. 绘制曲线连接 (Bezier Curve) - 原图特征
            ctx.strokeStyle = config.lineColor;
            ctx.lineWidth = 1;
            ctx.setLineDash([]); // 实线
            ctx.beginPath();
            ctx.moveTo(this.x + this.w/2, this.y + this.h); // 从框底
            // 贝塞尔控制点，让线弯曲得像数据线
            ctx.bezierCurveTo(
                this.x + this.w/2, this.y + this.h + 50, // 控制点1
                this.targetX, this.targetY - 50,        // 控制点2
                this.targetX, this.targetY              // 终点
            );
            ctx.stroke();

            // 连接点圆圈 (红色实心)
            ctx.fillStyle = config.nodeRed;
            ctx.beginPath(); ctx.arc(this.targetX, this.targetY, 3, 0, Math.PI*2); ctx.fill();
            // 框体上的红点
            ctx.beginPath(); ctx.arc(this.x + this.w, this.y, 4, 0, Math.PI*2); ctx.fill();


            // 2. 绘制方框
            ctx.strokeStyle = config.boxBorder;
            ctx.lineWidth = 1.2;
            ctx.strokeRect(this.x, this.y, this.w, this.h);

            // 3. 绘制内部 UI (黑白图表) - 核心视觉特征
            // 内部容器
            const innerPad = 10;
            const innerW = this.w - innerPad * 2;
            const innerH = this.h - 30;
            const startY = this.y + 20;
            const startX = this.x + innerPad;

            // 左侧黑色块
            ctx.fillStyle = 'rgba(0,0,0,0.85)';
            ctx.fillRect(startX, startY, innerW * 0.4, innerH * this.bar1);
            
            // 右侧白色块 (与黑色块形成对比)
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(startX + innerW * 0.45, startY + 10, innerW * 0.55, innerH * this.bar2);

            // 4. 文字
            ctx.fillStyle = '#fff';
            ctx.font = "bold 11px Courier New";
            ctx.fillText(this.label, this.x, this.y - 6);

            // 框内小字
            ctx.font = "8px Arial";
            ctx.fillStyle = '#ccc';
            ctx.fillText("Q: " + (this.bar1*100).toFixed(0), this.x + 5, this.y + this.h - 5);

            ctx.restore();
        }
    }

    // --- 3. 实例化 ---
    
    // 创建几层流场
    const streams = [];
    for(let i=0; i<5; i++) {
        // 分布在屏幕不同高度
        let y = window.innerHeight * (0.2 + i * 0.15);
        streams.push(new WaveStream(y, 30 + Math.random()*20, i, 1 + Math.random()));
    }

    // 创建节点框
    const nodes = [];
    for(let i=0; i<4; i++) nodes.push(new DataNode());

    // --- 4. 渲染循环 ---
    let time = 0;

    function animate() {
        ctx.clearRect(0, 0, w, h);
        time += 0.01;

        // A. 绘制地面透视网格 (Perspective Grid) - 营造空间感
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
        ctx.lineWidth = 1;
        ctx.setLineDash([2, 4]); // 虚线网格
        
        const horizon = h * 0.55; // 地平线
        const gridW = w * 2; // 网格延伸宽度
        const centerX = w / 2;

        ctx.beginPath();
        // 放射线 (纵向)
        for (let i = -10; i <= 10; i++) {
            let xOffset = i * 100;
            ctx.moveTo(centerX + xOffset * 0.1, horizon); // 远端聚拢
            ctx.lineTo(centerX + xOffset * 2, h);       // 近端发散
        }
        // 横线 (横向，随透视变密)
        for (let j = 0; j < 10; j++) {
            let y = horizon + Math.pow(j / 10, 2) * (h - horizon);
            ctx.moveTo(0, y);
            ctx.lineTo(w, y);
        }
        ctx.stroke();
        ctx.setLineDash([]); // 恢复实线


        // B. 绘制流场 (Stream Lines)
        streams.forEach(stream => stream.draw(ctx, time));

        // C. 绘制节点框 (Nodes)
        nodes.forEach(node => {
            node.update();
            node.draw(ctx);
        });

        // D. 绘制 UI 顶层文字
        drawOverlayUI();

        requestAnimationFrame(animate);
    }

    function drawOverlayUI() {
        // 右上角的数据块
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        ctx.fillRect(w - 160, 10, 150, 60);
        
        ctx.fillStyle = "#fff";
        ctx.font = "10px Courier New";
        ctx.textAlign = "left";
        ctx.fillText("[Migratory_Server]", w - 150, 25);
        ctx.fillStyle = "#aaa";
        ctx.fillText("Atmospheric modeling", w - 150, 40);
        ctx.fillText("Carbon credits: 89%", w - 150, 55);
    }

    startCamera();
    animate();

</script>
</body>
</html>
