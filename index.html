<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Eco-Data Monitoring System</title>
    <style>
        /* 基础设置，确保全屏无边距 */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #111; /* 深色背景，防闪烁 */
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace; /* 科技感等宽字体 */
        }

        /* 容器用于叠放视频和画布 */
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* 视频层：在最底层，直接显示摄像头画面 */
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* 确保画面填满屏幕 */
            z-index: 1;
            filter: grayscale(30%) contrast(1.1); /* 轻微调整视频风格以匹配氛围 */
        }

        /* 画布层：在视频之上，用于绘制所有数据UI */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2; /* 确保在视频上方 */
        }
    </style>
</head>
<body>

<div id="container">
    <video id="video" autoplay playsinline muted></video>
    <canvas id="canvas"></canvas>
</div>

<script>
    // --- 配置项 ---
    const config = {
        particleCount: 400, // 环境流动粒子数量（白色小点）
        connectionDistance: 80, // 粒子间连线的最大距离（橙色线）
        maxBoxes: 6, // 同时存在的最大跟踪框数量
        uiTextColor: 'rgba(255, 255, 255, 0.9)',
        flowDotColor: 'rgba(255, 255, 255, 0.6)',
        flowLineColor: 'rgba(255, 100, 50, 0.3)', // 橙色细线
        boxLineColor: 'rgba(255, 255, 255, 0.8)', // 白色框线
        connectorColor: 'rgba(255, 50, 50, 0.9)' // 红色连接线
    };

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let w, h; // 画布宽 高

    // --- 1. 初始化与摄像头设置 ---

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    async function startCamera() {
        try {
            // 优先请求后置摄像头 (environment)
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            video.srcObject = stream;
        } catch (e) {
            console.error("Camera access error:", e);
            // 如果失败（比如在电脑上），尝试请求任意摄像头
            try {
                const streamFallback = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
                video.srcObject = streamFallback;
            } catch (e2) {
                alert("无法访问摄像头。请确保在 HTTPS 环境下运行并授予权限。");
            }
        }
    }

    // --- 2. 系统组件定义 ---

    // 工具函数：生成随机标签
    function randomLabel() {
        const prefixes = ['F-Stage', 'P-3 v', 'Node-', 'Sensor '];
        const prefix = prefixes[Math.floor(Math.random() * prefixes.length)];
        const suffix = Math.floor(Math.random() * 99) + (Math.random() > 0.5 ? '' : '.1');
        return `[${prefix}${suffix}]`;
    }

    // 类：环境流粒子 (白色小点和橙色连线)
    class Particle {
        constructor() {
            this.reset();
            this.y = Math.random() * h; // 初始随机分布在全屏高度
            // 给一个随机初始相位，让波动看起来不那么整齐划一
            this.waveOffset = Math.random() * Math.PI * 2; 
        }
        reset() {
            this.x = Math.random() * w;
            // 从屏幕底部往上流，或者从左往右流。这里模拟图中略微向右上的趋势
            this.baseY = h + Math.random() * 200; 
            this.speedX = 0.5 + Math.random() * 1.5;
            this.speedY = -0.5 - Math.random() * 1;
            this.size = 1 + Math.random() * 1.5;
        }
        update() {
            this.x += this.speedX;
            this.baseY += this.speedY;
            // 加入正弦波运动，模拟气流/地形起伏
            this.y = this.baseY + Math.sin(this.x * 0.01 + this.waveOffset) * 30;

            // 飞出屏幕后重置
            if (this.x > w + 50 || this.y < -50) {
                this.x = -50;
                this.baseY = Math.random() * h + Math.random() * 200;
            }
        }
        draw(ctx) {
            ctx.fillStyle = config.flowDotColor;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // 类：数据跟踪框 (带黑白块和红线的方框)
    class TrackingBox {
        constructor() {
            this.reset();
            this.life = Math.random() * 200 + 100; // 初始给一个随机寿命
        }
        reset() {
            // 方框位置
            this.x = Math.random() * (w - 150);
            this.y = Math.random() * (h - 150);
            this.w = 80 + Math.random() * 60;
            this.h = 100 + Math.random() * 80;
            
            // 连接的目标点位置（模拟在地面/空中的某个点）
            this.targetX = this.x + (Math.random() - 0.5) * 300;
            this.targetY = this.y + 100 + Math.random() * 200;

            this.label = randomLabel();
            this.life = 300 + Math.random() * 300; // 总存活帧数
            this.maxLife = this.life;
            this.state = 'spawning'; // spawning, tracking, dying
            this.opacity = 0;
        }
        update() {
            this.life--;
            // 简单的状态机管理透明度
            if (this.life > this.maxLife - 50) {
                this.opacity += 0.02; // 渐显
            } else if (this.life < 50) {
                this.opacity -= 0.02; // 渐隐
            }
            if (this.opacity > 1) this.opacity = 1;
            if (this.opacity < 0) this.opacity = 0;

            // 缓慢移动，模拟跟踪
            this.x += (Math.random() - 0.5) * 0.5;
            this.y += (Math.random() - 0.5) * 0.5;

            if (this.life <= 0) this.reset();
        }
        draw(ctx) {
            if (this.opacity <= 0) return;
            ctx.save();
            ctx.globalAlpha = this.opacity;

            // 1. 绘制连接红线和目标点
            ctx.strokeStyle = config.connectorColor;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            // 从方框底部中心连到目标点
            ctx.moveTo(this.x + this.w / 2, this.y + this.h);
            ctx.lineTo(this.targetX, this.targetY);
            ctx.stroke();
            
            // 目标点圆圈
            ctx.fillStyle = config.connectorColor;
            ctx.beginPath();
            ctx.arc(this.targetX, this.targetY, 4, 0, Math.PI*2);
            ctx.fill();
            // 目标点外光环
            ctx.strokeStyle = config.connectorColor;
            ctx.beginPath();
            ctx.arc(this.targetX, this.targetY, 8 + Math.sin(Date.now()/200)*2, 0, Math.PI*2);
            ctx.stroke();


            // 2. 绘制方框主体
            ctx.strokeStyle = config.boxLineColor;
            ctx.lineWidth = 1;
            ctx.strokeRect(this.x, this.y, this.w, this.h);

            // 3. 绘制内部黑白数据块 (模拟图片中的样式)
            const blockH = 20;
            // 黑色底
            ctx.fillStyle = 'rgba(0,0,0,0.8)';
            ctx.fillRect(this.x + 5, this.y + this.h/2 - blockH, this.w - 10, blockH*2);
            // 白色块
            ctx.fillStyle = 'rgba(255,255,255,0.9)';
            ctx.fillRect(this.x + 10, this.y + this.h/2 - blockH + 5, 15, blockH*2 - 10);
            // 右侧白色小细条
            ctx.fillRect(this.x + this.w - 15, this.y + this.h/2 - 5, 5, 10);


            // 4. 绘制标签文字
            ctx.fillStyle = config.uiTextColor;
            ctx.font = "12px Courier New";
            ctx.fillText(this.label, this.x, this.y - 8);
            
            // 框内小文字
            ctx.font = "10px Courier New";
            ctx.fillText("DATA_STREAM...", this.x + 30, this.y + this.h/2 + 5);

            ctx.restore();
        }
    }


    // --- 3. 实例化系统 ---

    const particles = Array.from({ length: config.particleCount }, () => new Particle());
    const boxes = Array.from({ length: config.maxBoxes }, () => new TrackingBox());

    // --- 4. 主渲染循环 ---
    function animate() {
        ctx.clearRect(0, 0, w, h); // 清空画布

        // A. 绘制环境流系统 (点和网络线)
        ctx.lineWidth = 0.5;
        ctx.strokeStyle = config.flowLineColor;
        
        // 双重循环绘制粒子间的连线 (性能敏感点，注意粒子总数)
        for (let i = 0; i < particles.length; i++) {
            const p1 = particles[i];
            p1.update();
            p1.draw(ctx);

            // 寻找附近的粒子进行连接
            // 为了性能，只和数组中后面的粒子比较，避免重复计算
            for (let j = i + 1; j < particles.length; j++) {
                const p2 = particles[j];
                const dx = p1.x - p2.x;
                const dy = p1.y - p2.y;
                const distSq = dx * dx + dy * dy;

                // 如果距离小于设定值，则连接
                if (distSq < config.connectionDistance * config.connectionDistance) {
                    // 根据距离计算透明度，越远越淡
                    const alpha = 1 - Math.sqrt(distSq) / config.connectionDistance;
                    ctx.globalAlpha = alpha * 0.5; // 基础透明度乘数
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                }
            }
        }
        ctx.globalAlpha = 1; // 重置透明度

        // B. 绘制跟踪框系统
        boxes.forEach(box => {
            box.update();
            box.draw(ctx);
        });

        // C. 绘制顶部固定 UI
        drawTopUI();

        requestAnimationFrame(animate);
    }

    function drawTopUI() {
        ctx.save();
        ctx.fillStyle = config.uiTextColor;
        ctx.textAlign = 'right';
        
        ctx.font = "bold 14px Courier New";
        ctx.fillText("[Migratory_Server]", w - 20, 30);
        
        ctx.font = "12px Courier New";
        let startY = 50;
        const lines = [
            "Future Timescale : 100 yrs",
            "Atmospheric modeling",
            "Carbon credits",
            "[Flocking_permutations]"
        ];
        lines.forEach((line, i) => {
            ctx.fillText(line, w - 20, startY + i * 16);
        });

        // 简单的顶部线框云模拟 (用几个半透明椭圆)
        ctx.strokeStyle = "rgba(255,255,255,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(w - 150, 40, 100, 30, Math.PI / 12, 0, Math.PI * 2);
        ctx.stroke();
        ctx.beginPath();
        ctx.ellipse(w - 250, 20, 80, 20, -Math.PI / 12, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.restore();
    }


    // --- 启动 ---
    startCamera();
    animate();

</script>
</body>
</html>

