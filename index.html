<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cyber Vision Lite</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
        }

        /* 容器用于实现整体震动效果 */
        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* 视频直接铺满，不经过 JS 处理，性能最高 */
        video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* 保证铺满不留黑边 */
            z-index: 0;
        }

        /* 覆盖在上面的特效画布 */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* 纯 CSS 实现的轻量级 Glitch 故障条 */
        .glitch-line {
            position: absolute;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(255, 255, 255, 0.5);
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            animation: scanline 3s linear infinite;
        }

        @keyframes scanline {
            0% { top: -10%; opacity: 0; }
            50% { opacity: 0.5; }
            100% { top: 110%; opacity: 0; }
        }

        /* 模拟屏幕整体色差故障 */
        .screen-glitch {
            animation: rgbShift 0.2s steps(2) infinite;
            display: none; /* JS控制开启 */
        }

        @keyframes rgbShift {
            0% { transform: translate(2px, 0); filter: hue-rotate(90deg); }
            50% { transform: translate(-2px, 0); filter: hue-rotate(-90deg); }
            100% { transform: translate(0, 0); }
        }

    </style>
</head>
<body>

<div id="container">
    <video id="video" autoplay playsinline webkit-playsinline muted></video>
    <canvas id="canvas"></canvas>
    <div class="glitch-line" style="animation-delay: 0s;"></div>
    <div class="glitch-line" style="animation-delay: 1.5s;"></div>
</div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('container');

    // 适配屏幕
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // 1. 启动摄像头 (仅做显示，不做计算)
    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment', // 后置
                    width: { ideal: 1280 },
                    height: { ideal: 720 }
                },
                audio: false
            });
            video.srcObject = stream;
            video.play();
        } catch (e) {
            // 如果在电脑上没后置摄像头，会自动回退到前置
            console.log("Camera Error:", e);
            alert("请确保在 HTTPS 环境下运行，并允许摄像头权限。");
        }
    }

    // 2. 视觉模拟系统 (模拟 AI 识别框)
    const targets = [];
    
    // 生成随机字符串
    function randomStr() {
        const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        return chars.charAt(Math.floor(Math.random() * chars.length)) + 
               chars.charAt(Math.floor(Math.random() * chars.length)) + 
               "-" + Math.floor(Math.random() * 99);
    }

    class Target {
        constructor() {
            this.reset();
        }

        reset() {
            // 随机生成一个框的位置
            this.x = Math.random() * (canvas.width - 100);
            this.y = Math.random() * (canvas.height - 100);
            this.w = 50 + Math.random() * 100;
            this.h = 50 + Math.random() * 100;
            this.life = 60 + Math.random() * 100; // 存活帧数
            this.maxLife = this.life;
            this.label = randomStr();
            this.color = Math.random() > 0.8 ? '#00ffcc' : '#ffffff'; // 偶尔出现青色关键目标
            
            // 模拟“锁定”动画
            this.scale = 1.5; 
        }

        update() {
            this.life--;
            // 简单的漂移效果，模拟跟踪
            this.x += (Math.random() - 0.5) * 2;
            this.y += (Math.random() - 0.5) * 2;

            // 收缩动画
            if (this.scale > 1) this.scale -= 0.05;

            if (this.life <= 0) this.reset();
        }

        draw(ctx) {
            const alpha = Math.min(1, this.life / 20); // 消失时渐变
            ctx.strokeStyle = this.color;
            ctx.fillStyle = this.color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 1;

            const currentW = this.w * this.scale;
            const currentH = this.h * this.scale;
            const currentX = this.x - (currentW - this.w)/2;
            const currentY = this.y - (currentH - this.h)/2;

            // 绘制赛博风格的边角 (而不是完整的框)
            const len = 10;
            ctx.beginPath();
            // 左上
            ctx.moveTo(currentX, currentY + len); ctx.lineTo(currentX, currentY); ctx.lineTo(currentX + len, currentY);
            // 右上
            ctx.moveTo(currentX + currentW - len, currentY); ctx.lineTo(currentX + currentW, currentY); ctx.lineTo(currentX + currentW, currentY + len);
            // 右下
            ctx.moveTo(currentX + currentW, currentY + currentH - len); ctx.lineTo(currentX + currentW, currentY + currentH); ctx.lineTo(currentX + currentW - len, currentY + currentH);
            // 左下
            ctx.moveTo(currentX + len, currentY + currentH); ctx.lineTo(currentX, currentY + currentH); ctx.lineTo(currentX, currentY + currentH - len);
            ctx.stroke();

            // 绘制文字标签
            ctx.font = "12px Courier New";
            ctx.fillText(this.label, currentX + 4, currentY - 6);

            // 绘制装饰性虚线
            ctx.setLineDash([2, 4]);
            ctx.beginPath();
            ctx.moveTo(currentX + currentW + 5, currentY);
            ctx.lineTo(currentX + currentW + 30, currentY - 20);
            ctx.stroke();
            ctx.setLineDash([]); // 重置

            ctx.globalAlpha = 1;
        }
    }

    // 初始化 5 个模拟目标
    for(let i=0; i<6; i++) {
        targets.push(new Target());
    }

    // 3. 渲染循环
    let frame = 0;
    function loop() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 绘制网格背景 (Grid)
        ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
        ctx.lineWidth = 1;
        const gridSize = 80;
        // 简单的动态网格
        const offset = (Date.now() / 50) % gridSize; 
        
        // 竖线
        for (let x = offset; x < canvas.width; x += gridSize) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
        }
        // 横线
        for (let y = 0; y < canvas.height; y += gridSize) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }

        // 更新并绘制每一个目标
        targets.forEach(t => {
            t.update();
            t.draw(ctx);
        });

        // 随机的屏幕抖动效果 (Glitch)
        frame++;
        if (Math.random() > 0.98) {
            container.style.transform = `translate(${Math.random()*4-2}px, ${Math.random()*4-2}px)`;
            setTimeout(() => { container.style.transform = 'translate(0,0)'; }, 50);
        }

        // 右侧的数据瀑布流装饰
        ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
        ctx.font = "10px monospace";
        for(let i=0; i<10; i++) {
            ctx.fillText(Math.random().toFixed(4), canvas.width - 60, 50 + i * 15);
        }

        requestAnimationFrame(loop);
    }

    startCamera();
    loop();

</script>
</body>
</html>
