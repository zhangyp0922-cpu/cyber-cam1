<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sodeoka Isolux Effect</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #ui {
            position: absolute;
            bottom: 30px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            font-family: monospace;
            z-index: 10;
            pointer-events: none;
            mix-blend-mode: exclusion;
        }
    </style>
</head>
<body>

    <div id="ui">
        ISOLUX_RENDERER_V1<br>
        YOSHI_SODEOKA_STYLE<br>
        <span id="fps">FPS: --</span>
    </div>
    
    <canvas id="glcanvas"></canvas>

<script>
    // --- 1. 核心 WebGL 设置 ---
    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl');
    
    if (!gl) {
        alert("无法初始化 WebGL，您的浏览器可能不支持。");
    }

    // --- 2. Shader 程序 (这是显卡运行的代码，创造那种迷幻效果的关键) ---

    // 顶点着色器 (处理位置，简单的铺满屏幕)
    const vsSource = `
        attribute vec4 aVertexPosition;
        attribute vec2 aTextureCoord;
        varying highp vec2 vTextureCoord;
        void main(void) {
            gl_Position = aVertexPosition;
            vTextureCoord = aTextureCoord;
        }
    `;

    // 片元着色器 (处理像素颜色 - Isolux 算法就在这里)
    const fsSource = `
        precision highp float;
        varying highp vec2 vTextureCoord;
        uniform sampler2D uSampler;
        uniform float uTime;
        uniform vec2 uResolution;

        // 转换 RGB 到 亮度 (Luminance)
        float getLuma(vec3 color) {
            return dot(color, vec3(0.299, 0.587, 0.114));
        }

        // 伪随机噪声
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
        }

        void main(void) {
            // 1. 获取摄像头当前像素
            vec2 uv = vTextureCoord;
            // 简单的镜像处理
            // uv.x = 1.0 - uv.x; 
            
            vec4 texColor = texture2D(uSampler, uv);
            
            // 2. 计算亮度
            float luma = getLuma(texColor.rgb);

            // 3. 创造 Isolux (等照度线) 效果
            // 原理：用 sin 函数把连续的亮度切割成条纹
            // uTime 让线条缓缓流动
            float lines = sin(luma * 40.0 + uTime * 2.0); 
            
            // 让线条边缘锐利一点 (Step function)
            lines = smoothstep(0.4, 0.6, lines); 
            
            // 4. Sodeoka 风格配色 (霓虹热感图)
            // 我们根据亮度混合几种高饱和度颜色
            
            // 暗部：深蓝/紫
            vec3 col1 = vec3(0.1, 0.0, 0.3); 
            // 中部：洋红/红
            vec3 col2 = vec3(1.0, 0.0, 0.5); 
            // 亮部：青色/酸性绿
            vec3 col3 = vec3(0.0, 1.0, 0.8);
            
            vec3 finalColor = mix(col1, col2, luma * 2.0);
            if(luma > 0.5) finalColor = mix(col2, col3, (luma - 0.5) * 2.0);

            // 5. 叠加线条 (黑色指纹线)
            // 如果 lines 值低，就显示黑色，否则显示霓虹色
            // 增加一点噪声模拟模拟信号的粗糙感
            float noise = random(uv * uTime) * 0.1;
            
            if (lines < 0.2 + noise) {
                finalColor = vec3(0.0, 0.0, 0.0); // 线条颜色 (黑)
            } else {
                // 增加一点辉光感
                finalColor *= 1.2;
            }

            // 6. 稍微混合一点原始视频，增加层次感
            // finalColor = mix(finalColor, texColor.rgb, 0.2);

            gl_FragColor = vec4(finalColor, 1.0);
        }
    `;

    // --- 3. WebGL 辅助函数 ---
    function initShaderProgram(gl, vsSource, fsSource) {
        const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vsSource);
        const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fsSource);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert('Shader 初始化失败: ' + gl.getProgramInfoLog(shaderProgram));
            return null;
        }
        return shaderProgram;
    }

    function loadShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert('Shader 编译失败: ' + gl.getShaderInfoLog(shader));
            gl.deleteShader(shader);
            return null;
        }
        return shader;
    }

    const shaderProgram = initShaderProgram(gl, vsSource, fsSource);
    
    const programInfo = {
        program: shaderProgram,
        attribLocations: {
            vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
            textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
        },
        uniformLocations: {
            uSampler: gl.getUniformLocation(shaderProgram, 'uSampler'),
            uTime: gl.getUniformLocation(shaderProgram, 'uTime'),
            uResolution: gl.getUniformLocation(shaderProgram, 'uResolution'),
        },
    };

    // --- 4. 几何体设置 (一个矩形铺满屏幕) ---
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    const positions = [-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, 1.0];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

    const textureCoordBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
    const textureCoordinates = [0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0]; // 翻转Y轴适配 WebGL
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);

    // --- 5. 摄像头视频流处理 ---
    const video = document.createElement('video');
    video.autoplay = true;
    video.muted = true;
    video.playsInline = true;

    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            video.srcObject = stream;
            video.play();
            render();
        } catch (e) {
            alert("请使用 HTTPS 访问并允许摄像头权限。");
        }
    }

    // 创建纹理
    const texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    // 放入一个初始像素防止警告
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 255]));

    function updateTexture() {
        if (video.readyState >= video.HAVE_CURRENT_DATA) {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
        }
    }

    // --- 6. 渲染循环 ---
    let startTime = 0;
    
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);
    resize();

    function render(now) {
        now *= 0.001; // 转换为秒
        if (!startTime) startTime = now;
        const time = now - startTime;

        updateTexture();

        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.clear(gl.COLOR_BUFFER_BIT);

        gl.useProgram(programInfo.program);

        // 绑定位置
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.vertexPosition);

        // 绑定纹理坐标
        gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);
        gl.vertexAttribPointer(programInfo.attribLocations.textureCoord, 2, gl.FLOAT, false, 0, 0);
        gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);

        // 激活纹理
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.uniform1i(programInfo.uniformLocations.uSampler, 0);

        // 传递 Uniforms
        gl.uniform1f(programInfo.uniformLocations.uTime, time);
        gl.uniform2f(programInfo.uniformLocations.uResolution, canvas.width, canvas.height);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        requestAnimationFrame(render);
    }

    startCamera();

</script>
</body>
</html>
