<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Zine Cam</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            overflow: hidden;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100%;
        }

        /* 隐藏原始视频，我们只看处理后的 Canvas */
        video {
            display: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* 启动遮罩 */
        #overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            font-weight: bold;
            letter-spacing: 2px;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="container">
    <div id="overlay" onclick="startApp()">[ TAP TO START FILM ]</div>
    <video id="video" playsinline muted></video>
    <canvas id="canvas"></canvas>
</div>

<script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');

    let w, h;
    let frame = 0;

    // --- 1. 核心绘制循环 ---
    function render() {
        if (video.readyState === video.HAVE_ENOUGH_DATA) {
            // A. 绘制背景 (模拟胶片色彩)
            ctx.filter = 'contrast(0.9) brightness(1.1) sepia(0.6) saturate(1.5) hue-rotate(-10deg)';
            
            // 简单的居中裁剪绘制，防止变形
            const scale = Math.max(w / video.videoWidth, h / video.videoHeight);
            const xOffset = (w - video.videoWidth * scale) / 2;
            const yOffset = (h - video.videoHeight * scale) / 2;
            ctx.drawImage(video, xOffset, yOffset, video.videoWidth * scale, video.videoHeight * scale);
            
            ctx.filter = 'none'; // 重置滤镜以免影响后续绘制

            // B. 绘制左侧的三个“特写镜头” (Cutouts)
            // 逻辑：从画面中心附近截取小块，放大显示在左侧
            
            const boxW = w * 0.35; // 盒子宽度
            const boxH = boxW * 0.7; // 盒子高度
            const gap = 20;
            const startX = 30; // 左边距
            const startY = 50; // 顶边距

            // 定义三个框的抓取源 (Source) 和 放置目标 (Dest)
            const cutouts = [
                { 
                    // 框1：抓取画面中心偏上
                    sx: video.videoWidth * 0.4, sy: video.videoHeight * 0.3, 
                    sw: video.videoWidth * 0.2, sh: video.videoHeight * 0.2 
                },
                { 
                    // 框2：抓取画面正中心 (放大倍数更高)
                    sx: video.videoWidth * 0.45, sy: video.videoHeight * 0.45, 
                    sw: video.videoWidth * 0.1, sh: video.videoHeight * 0.1 
                },
                { 
                    // 框3：抓取画面中心偏下
                    sx: video.videoWidth * 0.3, sy: video.videoHeight * 0.6, 
                    sw: video.videoWidth * 0.2, sh: video.videoHeight * 0.2 
                }
            ];

            // 循环绘制这三个框
            cutouts.forEach((cut, i) => {
                const destY = startY + i * (boxH + gap);
                
                ctx.save();
                
                // 1. 绘制框内的视频内容
                // 这里也加一点点不同的滤镜，让拼贴感更强
                ctx.filter = 'contrast(1.2) sepia(0.4) saturate(1.2)';
                ctx.drawImage(video, cut.sx, cut.sy, cut.sw, cut.sh, startX, destY, boxW, boxH);
                ctx.filter = 'none';

                // 2. 绘制微弱的边框/阴影，增加纸张感
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                ctx.strokeRect(startX, destY, boxW, boxH);
                
                ctx.restore();
            });

            // C. 叠加复古纹理 (Texture Overlay)
            
            // 1. 暖色光晕 (Warm Tint Overlay)
            ctx.fillStyle = 'rgba(255, 160, 100, 0.15)'; // 橙红色半透明
            ctx.globalCompositeOperation = 'overlay'; // 叠加模式
            ctx.fillRect(0, 0, w, h);
            ctx.globalCompositeOperation = 'source-over'; // 恢复默认

            // 2. 噪点 (Noise)
            drawNoise(ctx, w, h);

            // 3. 折痕线 (Fold Lines) - 模拟海报折叠
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.lineWidth = 1;
            // 竖线
            ctx.beginPath(); ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h); ctx.stroke();
            // 横线
            ctx.beginPath(); ctx.moveTo(0, h/2); ctx.lineTo(w, h/2); ctx.stroke();


            // D. 绘制平面设计元素 (Graphics & Typography)
            
            ctx.fillStyle = '#fff';
            
            // 1. 文字 "(1)"
            ctx.font = '30px Helvetica';
            ctx.fillText('(1)', 40, h/2 + 40);

            // 2. 文字 "the Lamb" (右侧)
            ctx.font = '30px Helvetica';
            ctx.textAlign = 'right';
            ctx.fillText('the Lamb', w - 40, h/2 + 40);

            // 3. 斜线装饰 "///" (右上角)
            drawDiagonalLines(ctx, w - 80, 50);
            
            // 4. 斜线装饰 "///" (右下角)
            drawDiagonalLines(ctx, w - 80, h - 80);

        }
        
        frame++;
        requestAnimationFrame(render);
    }

    // 辅助：绘制噪点
    function drawNoise(ctx, w, h) {
        // 为了性能，我们不每帧都重新生成所有噪点，而是随机画一些
        // 更好的做法是预生成一张噪点图，这里用简易法
        const cx = Math.random() * w;
        const cy = Math.random() * h;
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        ctx.fillRect(0, 0, w, h); // 整体稍微提亮模拟胶片灰雾
    }

    // 辅助：绘制斜线 ///
    function drawDiagonalLines(ctx, x, y) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        const size = 40;
        const spacing = 15;
        
        for(let i=0; i<3; i++) {
            ctx.beginPath();
            ctx.moveTo(x + i*spacing, y + size);
            ctx.lineTo(x + i*spacing + size/2, y);
            ctx.stroke();
        }
    }

    // --- 启动逻辑 ---
    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    async function startApp() {
        overlay.style.display = 'none';
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { facingMode: 'environment', width: { ideal: 1280 }, height: { ideal: 720 } },
                audio: false
            });
            video.srcObject = stream;
            video.play();
            render();
        } catch (e) {
            alert("需要摄像头权限 / 请使用 HTTPS");
        }
    }

</script>
</body>
</html>
